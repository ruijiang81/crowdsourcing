#' decide_price_per_label
#' 
#' What does it do?
#' (1)	There are two sets of rules: (a) non data-driven (i.e. min_pay_per_label), and (b) data-driven (i.e. max_total_ratio).  According to the selected rule, the function returns a payment for the next iteration.
#' (2)	If a non data-driven rule was chosen, no model fitting is required and the returning value would be a number from the available costs values.
#' (3)	If a data-driven rule was chosen, cross validation per each available cost value is performed. In essence, we estimate the changes in AUC when omitting serval instances (a batch) bought at a particular payment value. We call these calculation “partial_model_performance”
#' (4)	We fit a model to all the data, estimate it’s performance by K-fold CV and call it “full_model_CV_performance”.
#' (5)	The detla_performance_improvement is the result of subtracting partial_model_performance from full_model_CV_performance. 
#' (6)	According to the data-driven rule, we decide what should be the next payment, that is, the return value.
#' INPUTS:
#' 1.	train; labeled set
#' 2.	pay_criteria; By which rule to decide how much to pay for the next batch?
#' 3.	payment_options; Available costs values
#' 4.	cur_instance_num; How many instances are in the model?
#' 5.	meta_data; Simulation log
#' 6.	repeatition_num; The current repetition value
#' 7.	inducer; What inducer should be used to fit models?
#' OUTPUT:
#' A scalar – the payment for the next iteration.
#' 


decide_price_per_label <- function(train,
                                   # By which rule to decide how much to pay for the next batch?
                                   pay_criteria,
                                   # Available costs values                                   
                                   payment_options,
                                   # How many instances are in the model ?
                                   cur_instance_num,
                                   # Simulation log
                                   meta_data,
                                   # The current repetition value
                                   repeatition_num,
                                   # What inducer should be used to fit models?
                                   inducer=c("RF","GLM","J48"))
{
    ####################
    # Input Validation #
    ####################
    assertive::assert_all_are_existing(c("UID",
                                         "k_path_temporary"))
    #'
    #########
    # Setup #
    #########
    output_full <- file.path(k_path_temporary, "full_performance_improvements.txt")
    output_delta <- file.path(k_path_temporary, "delta_performance_improvements.txt")
    if(file.exists(output_full)) file.remove(output_full)
    if(file.exists(output_delta)) file.remove(output_delta)
    #'
    if (pay_criteria =="random"){
        set.seed(cur_instance_num*global_seed)
        pay<-sample(payment_options,1)
        
    } else if (pay_criteria == "min_pay_per_label"){
        pay<-payment_options[which.min(payment_options)]
        
    } else if (pay_criteria == "max_pay_per_label"){
        pay<-payment_options[which.max(payment_options)]
        
    } else if (substr(pay_criteria,1,6) == "always"){
        pay <- substr(pay_criteria, 8, nchar(pay_criteria))
        
    } else if (pay_criteria %in% c("max_quality","max_ratio","max_total_ratio","delta_AUC_div_total_cost")){
        # for testing  
        #payment_options<-price_per_label_values
        #train<-training_set
        #meta_data<-metadata
        #cur_instance_num<-250
        #
        columns_names <- c(payment_options)
        summary_partial_model_performance <- read.table(text = "", col.names = columns_names)
        
        num_payment_options<-length(payment_options) 
        full_model_CV_performance<-cross_validation(train,
                                                    cross_validation_folds,
                                                    cross_validation_reruns,
                                                    inducer=inducer)
        full_model_CV_performance
        for (i in 1:num_payment_options) {
            #print (i)
            for (j in 1:number_batch_omissions){
                #print (j)
                payment_row_numbers<-which(meta_data$pay == payment_options[i]) #row number with this payments 
                
                if(length(payment_row_numbers)>max_instances_in_history) {
                    payment_row_numbers<-tail(payment_row_numbers,max_instances_in_history)
                }
                
                set.seed(cur_instance_num*global_seed+i+j*1000)
                random_rows_to_remove_with_payment     <- sample(payment_row_numbers, batch_size) 
                randomly_remaining_instances           <- train[-random_rows_to_remove_with_payment, ]; 
                summary_partial_model_performance[j,i] <- cross_validation(randomly_remaining_instances,
                                                                           cross_validation_folds,
                                                                           cross_validation_reruns,
                                                                           inducer=inducer)
            }
        }  
        partial_model_performance<-colMeans(summary_partial_model_performance, na.rm = FALSE, dims = 1) #vector with the average performance of the partial models per payment option
        delta_performance_improvement<-full_model_CV_performance-partial_model_performance #vector with average delta improvement over a the full model    
        
        out_delta <- toString(c(cur_instance_num,delta_performance_improvement))
        out_full  <- toString(c(cur_instance_num,full_model_CV_performance))
        
        #################
        # Store results #
        #################
        cat(out_full, file = output_full, sep = "\n", append = TRUE) 
        cat(out_delta, file = output_delta, sep = "\n", append = TRUE) 
        #'
        if (pay_criteria =="max_quality"){ 
            pay<-payment_options[which.max(delta_performance_improvement)]
        } 
        
        if (pay_criteria =="max_ratio"){
            if (max(delta_performance_improvement)<0){
                # in this case all values are negative so falling back to the max quality rule
                print ("used_safety_net")
                pay<-payment_options[which.max(delta_performance_improvement)]
            } else {
                ratio_performance<-delta_performance_improvement/payment_options
                pay<-payment_options[which.max(ratio_performance)]
            }
        }
        
        if (pay_criteria =="max_total_ratio"){
            if (max(delta_performance_improvement)<0){
                # in this case all values are negative so falling back to the max quality rule
                print ("used_safety_net")
                pay<-payment_options[which.max(delta_performance_improvement)]
            } else {
                for (t in 1:num_payment_options){
                    if (delta_performance_improvement[t]<0)       #using a large negative number to eliminate out of consideration negative delta improvements (in case part of them are negative and part positive)
                    {delta_performance_improvement[t]=-100000000}
                }
                expected_performance<-delta_performance_improvement+full_model_CV_performance
                expected_total_cost<-meta_data$cost_so_far[cur_instance_num-1]+batch_size*payment_options
                total_ratio_performance<-expected_performance/expected_total_cost
                pay<-payment_options[which.max(total_ratio_performance)]
            }
        }
        
        if (pay_criteria =="delta_AUC_div_total_cost"){
            if (max(delta_performance_improvement)<0){
                # in this case all values are negative so falling back to the max quality rule
                print ("used_safety_net")
                pay<-payment_options[which.max(delta_performance_improvement)]
            } else {
                expected_total_cost<-meta_data$cost_so_far[cur_instance_num-1]+batch_size*payment_options
                ratio_delta_AUC_div_total_cost<-delta_performance_improvement/expected_total_cost
                
                pay<-payment_options[which.max(ratio_delta_AUC_div_total_cost)]
            }
        }
        
    }
    
    else {
        stop("WRONG CRITERIA in decide_price_per_label")  
    }
    
    return(as.numeric(pay))
} # end decide_price_per_label
